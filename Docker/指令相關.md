## Docker 指令相關

- docker logs [容器 ID 或 容器名稱]
  嘗試運行 docker logs 命令來查看容器內應用程式的日誌輸出，這可能會提供有關錯誤原因的更多細節。你也可以使用 docker inspect 指令來查看容器的詳細信息，包括其配置和狀態。

- docker exec -it <container_name_or_id> /bin/bash
  使用以上指令進入 Docker 即可在 Docker 容器中查看具體目錄，進入容器後，你可以像在普通的 Linux 系統中一樣使用命令來查看檔，比如 ls、cd、cat 等。

- exit
  使用以上指令即可退出 Docker

- docker-compose logs app
  查看容器日志以了解服務器是否啟動成功以及是否存在錯誤。

- docker-compose down
  這個指令會停止並移除由 docker-compose 管理的容器、網絡和關聯的資源。換句話說，它會關閉並清理所有在 docker-compose 文件中定義的服務。

- docker-compose up --build
  這個指令會啟動 docker-compose 文件中定義的所有服務。如果加上 --build 選項，它會在啟動容器之前重新構建所有的 Docker 映像。這對於你在 Dockerfile 或上下文中做了更改後，確保最新的更改被應用非常有用。

- 簡單來說：
  docker-compose down 會關閉和移除所有服務。
  docker-compose up --build 會重新構建映像並啟動所有服務。

---

- docker image ls
  列出現在所有的 image

- docker ps
  使用以上指令即可列出當前正在運行的容器，以獲取你想查看的容器的名稱或 ID

- docker ps -a
  使用以上指令即可列出當前正的容器，包含停止的

---

**如何執行 docker image**

- docker run -d -p 80:80 nginx
  啟動一個 Nginx 容器

  - -d: 後台執行
  - -p 80:80: 將容器的 80 端口映射到主機的 80 端口
  - nginx: 使用 nginx 映像

- docker run -p 80:80 -d --name my-nginx nginx

  - docker run：這是 Docker 用來啟動一個新容器的基本指令。
  - -p 80:80：這部分指定了端口映射。
  - 80:80 左邊的 80 代表的是 本機 (host) 的端口。也就是說，當你在瀏覽器輸入 http://localhost 的時候，實際上是對應到容器內的服務。80:80 右邊的 80 代表的是 容器 (container) 內的端口。Nginx 這個容器通常會監聽 80 端口，也就是標準的 HTTP 端口。
  - -d：這個參數表示在後台運行容器。也就是說，執行完這個指令後，容器會在背景繼續運行，而你可以在終端中繼續執行其他指令。
  - --name my-nginx：這個參數給容器命名為 my-nginx。這樣一來，你就可以用這個名字來管理這個容器，例如停止、啟動或刪除它。
  - nginx：這指定了要使用的映像名稱。nginx 是一個官方的 Nginx 映像，包含了一個預先配置好的 Nginx 伺服器。

  - docker run --name myapp_c2 -p 4000:4000 -d myapp
    其中 -d 可以放在任意位置這樣也是可以的

---

當你下載了 Node.js 的 Docker 映像並嘗試運行後容器卻立即停止，通常是因為 Docker 容器的預設行為：如果容器內的主進程結束，容器就會停止。這是由於 Node.js 映像中沒有啟動持續運行的進程，而容器的生命週期與主進程綁定。

1. 容器啟動後，沒有主進程持續運行
   如果你只是執行以下命令：
   ```bash
   docker run node
   ```
   默認情況下，node 進入一個 REPL（交互式命令行），但如果沒有任何輸入，REPL 就會關閉，容器也會停止。
   - 解決方法：
     運行容器時加上交互模式（-it），這樣可以進入 Node.js 的 REPL 並保持容器運行：
     ```bash
     docker run -it node
     ```
     這會讓你進入 Node.js 的命令行環境，可以直接執行 JavaScript。

---

**Docker 的 Digest 是什麼**

在 Docker 中，Digest 是映像的唯一標識符。它是一種基於內容的哈希值（通常是 SHA256），用於確保 Docker 映像的完整性和唯一性。Digest 是由映像的內容計算出的，因此相同內容的映像會有相同的 Digest，不管它們的標籤（tag）如何。

- Digest 的作用

  - 唯一性：Digest 保證了映像的內容是唯一的。任何微小的改動（如配置或文件變動）都會導致 Digest 改變。
  - 版本控制：即使標籤改變（如 latest），Digest 依然保持一致，因此能準確指向特定的映像版本。
  - 安全性：使用 Digest 可以防止映像被篡改，因為 Digest 是基於內容生成的，改變內容會導致哈希值不同。

- 如何使用 Docker Digest？

  - 獲取映像的 Digest
    當你拉取或查看 Docker 映像時，可以使用以下方式取得 Digest：

    ```bash
    <!-- 拉取映像並查看 Digest： -->
    docker pull <image_name>:<tag>
    docker inspect --format='{{index .RepoDigests 0}}' <image_name>

    <!-- 實際例子 -->
    docker pull nginx:latest
    docker inspect --format='{{index .RepoDigests 0}}' nginx

    <!-- 列出所有映像的 Digest： -->
    docker images --digests
    ```

  - 使用 Digest 拉取特定映像版本
    Digest 確保你拉取的映像與預期一致，避免因標籤（tag）變動導致的版本不匹配。

    ```bash
    <!-- 命令格式： -->
    docker pull <image_name>@<digest>

    <!-- 實際例子 -->
    docker pull nginx@sha256:3b9c70b01134f9654bcf308fb4cabe6ab4e1d58e26ef17dd0bfed7b8ef113d27
    ```

  - 使用 Digest 在 Dockerfile 中指定映像
    在 Dockerfile 中，可以使用 Digest 來確保基礎映像的版本不變：

    ```bash
    FROM nginx@sha256:3b9c70b01134f9654bcf308fb4cabe6ab4e1d58e26ef17dd0bfed7b8ef113d27
    ```

  - 驗證 Digest
    如果你需要檢查一個本地映像的 Digest，可以使用：

    ```bash
    docker inspect --format='{{.Id}}' <image_name>
    ```

---

**如何建立 docker image**

- docker build -t myapp .
  這段命令是用來構建一個 Docker 映像，並將其命名為 myapp。下面是詳細的解析：

  - docker build
    Docker 用於構建映像的命令，根據 Dockerfile 和相關資源構建一個新的映像。
  - -t myapp
    這裡的 -t 是標籤（tag）的縮寫，用來為映像指定名稱和可選的標籤（默認是 latest）。
    在這個例子中：
    - myapp 是映像的名稱（name）。
    - 如果未指定標籤，Docker 默認標籤為 latest，所以實際上等價於 myapp:latest。
  - .（點）
    表示構建上下文（build context），即 Docker 構建過程中可用的文件和目錄範圍。
    - . 代表當前目錄，Docker 會使用當前目錄下的 Dockerfile 和其他相關文件進行構建。

---

忽略某些資料夾不用複製如 node_modules
則可以使用 .dockerignore

```bash
node_modules/
```

則 node_modules 就不會被複製進 container 裡面

---

**如何停止 container**

```bash
docker stop myapp_c1(container 的名字)
docker stop a722cab96aef(container id)
```

---

**如何開始 container**

```bash
docker start myapp_c2(container 的名字)
```

---

**如何移除 image**

```bash
docker image rm myapp

# 強制刪除的話加上 -f
docker image rm myapp5 -f
```
